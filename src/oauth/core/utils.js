import JSChaCha20 from "js-chacha20";

/**
 * weakRand is used to generate start values.
 * It don't have to be "securely" random, but merely unpredictable. 
 * */
const weakRand = (size) => {
  let buf = new Uint8Array(size);
  for (let i = 0; i < size; i++) {
    buf[i] = Math.round(Math.random() * 256);
  }
  return buf;
}

export const getRandomValue = (size) => {
  const key = weakRand(32);
  const nonce = weakRand(12);
  const counter = 1;
  const chacha = new JSChaCha20(key, nonce, counter);

  // We will use the same buffer for keeping pre-generated bytes.
  // Start with a buffer of simply anything, as it will be turned into noise anyway.
  let buffer = new Uint8Array(Array(64).fill(1));

  // Pos is the number of invalid buffer bytes.
  let pos = buffer.length;

  // Returns a new random byte.
  function nextByte() {
    // If all bytes in the buffer have been invalidated, generate a new one.
    if (pos >= buffer.length) {
      buffer = chacha.encrypt(buffer);
      pos = 0;
    }
    return buffer[pos++];
  }

  if (size < 1 || size > 16) {
    throw new Error("Invalid size argument: " + size);
  }
  
  let result = 0;
  while (size > 0) {
    size--;
    result = nextByte();
  }
  return result;
}